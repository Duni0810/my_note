---
title: 数据结构---通用树实现
tags: young
grammar_abbr: true
grammar_table: true
grammar_defList: true
grammar_emoji: true
grammar_footnote: true
grammar_ins: true
grammar_mark: true
grammar_sub: true
grammar_sup: true
grammar_checkbox: true
grammar_mathjax: true
grammar_flow: true
grammar_sequence: true
grammar_plot: true
grammar_code: true
grammar_highlight: true
grammar_html: true
grammar_linkify: true
grammar_typographer: true
grammar_video: true
grammar_audio: true
grammar_attachment: true
grammar_mermaid: true
grammar_classy: true
grammar_cjkEmphasis: true
grammar_cjkRuby: true
grammar_center: true
grammar_align: true
grammar_tableExtra: true
---
==文档制作工具：小书匠（markdown工具）==
==制作人     ：young==
==制作时间：2018-10-20==


----------

# 树的概念

这篇开始我们开始说说复杂的点的数据结构。之前介绍的数据结构比较简单，也使用的比较广泛，比较好理解。这篇开始的数据结构可能会复杂点，但是也相对比较有意思。
这篇呢，我们先介绍”树“这种数据结构，我们先看下下面这张图：

![树的表示](./images/数的表示.png)

从图中我们可以看出我们应用这种数据结构是一对多的形式，这个和我们之前的链表不太一样，链表是一对一形式。我们生活中也经常用这种数据结构，例如：家谱，还有目录结构。其实用的就是这种数据结构。

树中有机构和基本的概念，我们得理解下，否则会给之后的代码带来困扰。

1. 树的结点包含一个数据及若干指向子树的分支。
2. 结点拥有的子树数称为结点的度。
度为0的结点称为叶结点。
度不为0的结点称为分支结点。
3. 树的度定义为所有结点中的度的最大值。
4. 结点的直接后继称为该结点的孩子，相应的，该结点称为孩子的双亲。
5. 结点的孩子的孩子的……称为该结点的子孙，相应的，该结点称为子孙的祖先。
6. 同一个双亲的孩子之间互称兄弟。
7. 结点的层次。
根为第1层
根的孩子为第2层
……
8. 树中结点的最大层次称为树的深度或高度。

![树的概念](./images/树概念.png)

9. 如果树中结点的各子树从左向右是有次序的，子树间不能互换位置，则称该树为有序树，否则为无序树。

![有序树与无序数](./images/数的序.png)

10. 森林是由 n ( n ≥0 ) 棵互不相交的树组成的集合。

![森林](./images/森林.png)

从上面的概念和图来看，应该不难理解这个树的一些概念了。


# 树的存储结构

现在呢树的概念我们是理解里，但是我应该怎么存储这种树的结构呢？因为树中的每个节点的孩子数目不是固定的，怎么定义他呢？主要是从根节点到叶节点不是线性，但是叶节点到根节点是线性。

其实我们可以设计结构体数组对节点的关系进行表述，如下图：

![位置表示](./images/解决1.jpg)

![位置逻辑](./images/逻辑关系.png)

利用上面的关系就可以将数的关系理清楚，但是怎么存储还是没清晰。我们可以创建一个通链，这个通链就是将树中的各个节点串一起，然后每个树节点自己管理自己的自己的孩子节点，孩子节点也是通过链表串成。具体看下图：

![树的详细架构图](./images/架构图.png)

这里有基地几点要说明下：（0）我们利用链表组织树中的各个结点；（1）链表中的前后关系不代表结点间的逻辑关系；（2）结点的逻辑关系由child数据域描述；（3）child数据域保存其他结点的存储地址；（4）树中每一个结点都是同一个链表中的数据元素。

有上面的关系我们可以得出树的框架，如下：

``` c

// GTree 节点信息结构体 
typedef struct _tag_GTreeNode {
	GTreeData *data;	// 节点数据 
	LinkList  *child;	// 孩子节点 
	struct _tag_GTreeNode *parent;	// 父亲节点
} tree_node_t;

// 链式树节点 
typedef struct _tag_TLNode {
	LinkListNode_t header;
	tree_node_t   *node; 
} tree_list_node_t;
```
其中关于 ==GTree== 和 ==GTreeData== 的类型为 void , 为了做数据封装，在 ==.h== 文件中定义。
# 通用树代码实现

树也是一种数据结构，所以他的操作和之前说的链表也有相似的地方，但是他也有自己特有的操作，如下：
 * 创建树
 * 销毁树
 * 清空树
 * 插入树节点
 * 删除树节点
 * 获取树节点
 * 获取根节点
 * 获取树的节点树
 * 获取树的高度
 * 获取树的度
 * 获取树的位置

我们是和之前的一样，对树的一些操作当作函数一样的实现。

## 创建树

之前说过通用树的实现实际上用了一个通链将树中的元素串在一起，所以创建树复用了单链表的代码。我们这里创建的链表为通链的头而已。

``` c
// 1.创建树 
GTree *GTree_Create(void)
{
	return LinkList_Create();
}
```

## 插入树元素


















