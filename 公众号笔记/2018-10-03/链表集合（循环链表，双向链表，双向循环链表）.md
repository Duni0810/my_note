---
title: 链表集合（循环链表，双向链表，双向循环链表）
tags: young
grammar_abbr: true
grammar_table: true
grammar_defList: true
grammar_emoji: true
grammar_footnote: true
grammar_ins: true
grammar_mark: true
grammar_sub: true
grammar_sup: true
grammar_checkbox: true
grammar_mathjax: true
grammar_flow: true
grammar_sequence: true
grammar_plot: true
grammar_code: true
grammar_highlight: true
grammar_html: true
grammar_linkify: true
grammar_typographer: true
grammar_video: true
grammar_audio: true
grammar_attachment: true
grammar_mermaid: true
grammar_classy: true
grammar_cjkEmphasis: true
grammar_cjkRuby: true
grammar_center: true
grammar_align: true
grammar_tableExtra: true
---
==文档制作工具：小书匠（markdown工具）==
==制作人     ：young==
==制作时间：2018-10-3==


----------

这篇文章讲解下 **==循环链表==** ，==**双向链表**== 和 ==**双向循环链表**== 的实现，其实他们的实现和是在单链表的基础上实现的，这里我们只讲关于实现他们的注意事项，其实他们呢实现过程中，要注意的点只有两个， **==插入和删除的第一个节点的处理 #e03324==** 。

# **1. 循环链表**

在循环链表中，他的特点无非是最后一个节点指向第一个节点构成一个循环（如果只有一个节点，那么这这个节点就是指向自己）。画个图理解下就比较直观。

![循环链表](./images/介绍.jpg)

这个好理解，我们现在说说循环链表的插入操作点，一样用画图的方式理解。

## **2.循环链表的插入**

先看下图

![循环链表的插入](./images/循环链表的插入.jpg)

图中的（a1）（a2）为一组；（b1）（b2）为一组。那么我们分两组来讨论这个问题，下面我就简称**a组**和**b组**了。

对于b组而言：数据内容是插入到头指针指向的第一个节点位置，所以我们要变化的是找到节点位置，将待插入的节点指向下一个节点，上一个节点指向插入的节点就可以了。

``` clj
		 node->next   = current->next;
		 current->next = node; 
```

对于a组而言：数据内容是插入到头指针指向的第一个节点位置，所以我们要变化的不仅仅是找到最后一个节点，将最后一个节点指向第一个节点（插入的节点），**我们还要做的是将头指(Head)针指向插入的节点**。

代码实例如下：

``` c
// 插入节点 
// 1.参数合法性判断
// 2.找到插入位置
// 3.实施插入算法，并将链表信息的长度加 1 
// 4.插入有几个比较特殊的地方：如果是空；
//	(1)链表插入的话，游标指向第一个元素；
//	(2)如果是插入在第一个元素的话,我们得找到链表的最后一个元素，将他的next指向插入的元素 
int CircleList_Insert(CircleList *list, circlelist_node_t *node, int pos)
{
	int i = 0;
	circlelist_t *slist = (circlelist_t *)list;  // 类型解封装 
	int ret = ((slist != NULL) && (node != NULL) && (pos >= 0));
	
	// 参数合法
	if (ret) {  
		circlelist_node_t *current = (circlelist_node_t *)slist;
		 
		 // 遍历链表的位置 
		 for (i = 0; (i < pos) && (current->next != NULL); i++) {
		 	current = current->next; 
		 }
		 
		 // 找到位置之后 插入链表  node 就是我们要插入的链表
		 // 这里的操作和单链表一致 
		 node->next   = current->next;
		 current->next = node; 
		 
		 // 如果是第一次插入的话要让 node 指向自己
		 if (slist->length == 0) {
		 	slist->slider = node;
		 } 
		 
		 // 插入一个节点位置自然要加 1 处理 
		 slist->length++;
		  
		 // 这里我们做的是循环链表 所以有几个特殊的位置需要单独的处理
		 // 例如  如果是插入第一个位置的话 
		 if (current == (circlelist_node_t *)slist) {
			// 如果插入的位置在头指针，那么要找到最后一个元素，
			//然后将最后一个元素的下一个位置指向current的下一个 
		 	circlelist_node_t *last = CircleListNode_Get(slist, slist->length - 1);
		 	last->next = current->next;
		 }
	}	
	return ret;
}
```

 _代码中的的slider是游标，详情看代码悉知。_


## **3.循环链表的删除**

一样先上图。

![循环连表的删除](./images/循环链表删除.jpg)

图中图（a）是原始的链表，图（b）是删除第一个节点后的链表，图（c）是删除中间任意节点的链表，这个我们好理解，删除一个节点无非是将上一个节点链接就可以了。

``` clj
		ret = current->next;
		current->next = ret->next;
```

但是也有一个特殊的地方，那就是第一个元素，要特殊处理，其实也就多了两步：
 : 找到最后一个元素，将最后一个元素指向删除元素的下一个元素
 : 头指针指向删除元素的下一个元素

_代码中用到一个游标参数，如果游标正好指向删除元素的话，将游标指向删除元素的下一个元素_




















