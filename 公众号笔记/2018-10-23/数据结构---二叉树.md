---
title: 数据结构---二叉树
tags: young
grammar_abbr: true
grammar_table: true
grammar_defList: true
grammar_emoji: true
grammar_footnote: true
grammar_ins: true
grammar_mark: true
grammar_sub: true
grammar_sup: true
grammar_checkbox: true
grammar_mathjax: true
grammar_flow: true
grammar_sequence: true
grammar_plot: true
grammar_code: true
grammar_highlight: true
grammar_html: true
grammar_linkify: true
grammar_typographer: true
grammar_video: true
grammar_audio: true
grammar_attachment: true
grammar_mermaid: true
grammar_classy: true
grammar_cjkEmphasis: true
grammar_cjkRuby: true
grammar_center: true
grammar_align: true
grammar_tableExtra: true
---
==文档制作工具：小书匠（markdown工具）==
==制作人     ：young==
==制作时间：2018-10-22==


----------

# 二叉树的定义（孩子兄弟表示法）
上一篇文章我们提到 ==双亲孩子表示法== 实现的二叉树，他的性质为：（1）每个结点都有一个指向其双亲的指针；（2） 每个结点都有若干个指向其孩子的指针。实际上我们还有另一种表示方法叫 ==孩子兄弟表示法== 。我们先看下他长什么样子。

![孩子兄弟表示法](./images/孩子兄弟表示法_1.png)

孩子兄弟表示法模型每个结点包含一个数据指针和两个结点指针，性质如下：（1）每个结点都有一个指向其第一个孩子的指针；（2）每个结点都有一个指向其第一个右兄弟的指针。
孩子兄弟表示法的特点
* 能够表示任意的树形结构
* 每个结点中有且仅有三个指针域
 数据指针，孩子结点指针，兄弟结点指针
* 每个结点的结构简单,只有孩子结点指针和兄弟结点指针构成了“树杈”

二叉树的定义如下：二叉树是由 n ( n ≥0 ) 个结点组成的有限集合，该集合或者为空，或者是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。
## 特殊的二叉树

### 完全二叉树
完全二叉树 (Complete Binary Tree)如果一棵具有n个结点的高度为k的二叉树，它的每一个结点都与高度为k的满二叉树中编号为1—n的结点一一对应，则称这棵二叉树为完全二叉树。（从上到下从左到右编号）。

![完全二叉树](./images/完全二叉树.png)


### 满二叉树 (Full Binary Tree)
如果二叉树中所有分支结点的度数都为2，且叶子结点都在同一层次上，则称这类二叉树为满二叉树。

![满二叉树](./images/满二叉树.png)



（1）完全二叉树的叶结点仅出现在最下面两层；（2）最下层的叶结点一定出现在左边；（3）倒数第二层的叶结点一定出现在右边；（4）完全二叉树中度为1的结点只有左孩子；（5）同样结点数的二叉树，完全二叉树的高度最小；（6）满二叉树一定是完全二叉树，完全二叉树不是满二叉树。

## 二叉树的性质

性质一：在而二叉树的第 i 层最多有 2^i-1^ 个树节点。（i≥1）
性质二：深度为k的二叉树最多有2^k^-1 个节点（k ≥0）
性质三：对任意一棵二叉树，如果其叶节点有n~0~个，度为2的非叶节点有n~2~个，则有n~0~ = n~2~ + 1。
性质四：具有n个节点的完全二叉树的高度为 |log~2~n| +1。
性质五：一棵有n个节点的二叉树，按层次对节进行编号（从上到下，自左向右），对任意节点i 有：
 * 如果 i = 1，则节点 i是二叉树的根；
 * 如果i > 1，其父节点为|i/2|；
 * 如果 2i <= n，则节点 i 的左孩子为2i；
 * 如果 2i > n ，则节点 i 无左孩子；
 * 如果 2i + 1 <= n，则节点的右孩子为2i + 1；
 * 如果 2i + 1 > n，则节点i无右孩子；


# 创建二叉树

因为二叉树只有两个孩子，所以他的结构也相对简单不少，毕竟孩子有限，和我们之前的结构比是简单不少。因为他只有两个孩子所以他的定位也容易了不少。这里我们使用新的一种定位方式，就是指路法。
所谓的指路法是通过根节点与目标节点的相对位置进行定位，指路法的好处是可以避开二叉树递归的性质的一种线性定位方法，我们在C语言中是通过bit位来进行指路。假设我们定义左走为0，右走为1，如下图：

![指路法示意图](./images/指路法示意图.png)

例如我们要找到他的节点9的路径{左，左，右}，就可以到。所以我们用结构来定义他的指针域。

``` c
// 树节点结构体 
typedef struct _tag_BTreeNode {
	struct _tag_BTreeNode *left;		// 左子树 
	struct _tag_BTreeNode *right;	// 右子树 
} BTreeNode;
```
因为树结构不是线性结构，我们也可以用结构体定义他的头节点，如下：

``` c
typedef struct _tag_BTree {
	int count;		// 树节点
	BTreeNode *root;	// 根节点
} btree_t;
```

## 代码实现

树的操作和之前实现的通用树差不多，无非是插入，删除，高度，度等。下面来一个一个讲解如何实现的。

### 创建树

申请一段空间，并将头节点信息初始化。代码如下：

``` c
// 创建树 
BTree *BTree_Create()
{
	btree_t *ret = (btree_t *)malloc(sizeof (btree_t));
	if (ret != NULL) {
		ret->root = NULL;
		ret->count = 0;
	}
	return ret;
}
```




