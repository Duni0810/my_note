---
title: 编程技巧
tags: young
grammar_abbr: true
grammar_table: true
grammar_defList: true
grammar_emoji: true
grammar_footnote: true
grammar_ins: true
grammar_mark: true
grammar_sub: true
grammar_sup: true
grammar_checkbox: true
grammar_mathjax: true
grammar_flow: true
grammar_sequence: true
grammar_plot: true
grammar_code: true
grammar_highlight: true
grammar_html: true
grammar_linkify: true
grammar_typographer: true
grammar_video: true
grammar_audio: true
grammar_attachment: true
grammar_mermaid: true
grammar_classy: true
grammar_cjkEmphasis: true
grammar_cjkRuby: true
grammar_center: true
grammar_align: true
grammar_tableExtra: true
---
==文档制作工具：小书匠（markdown工具）==
==制作人     ：young==
==制作时间：2018-11-24==


----------


来工作了这么久，其实嘛，也学到了一些东西，实实在在东西就不说了。比如XXX驱动，XXX开发板呀啥的。我觉得嘛，我们做程序员的，不应该是码农，应该努力做一个工程师。他们有啥区别呢？
于我而言，码农，就是纯粹敲代码的人。在国内，绝大多数应该都是码农。大多没有多少的创造力，因为我们现在所做的东西，95%都能在百度找到，还有的4%应该能在google中找到，最后的1%就是属于大神们的创造了。码农的工作实际上只是为了完成任务而存在的，而对于工程师而言，他们是有一定的自我创造能力的，他们是为了解决某个具体的问题而存在的，或者在某一项领域中小有研究，能在其中找到灵感。
在某种意义上，我也是码农。所以我一就直认为，我们做程序员的，我们的工作意义不是写代码，而是理解为什么要这样写以及这样写的好处是啥，应该了解他背后的深层次的含义。
好吧好吧，扯的有点多。这周就聊聊从开始工作至今，我工作中的一些编程的想法和技巧，如果能耐心看完这篇文章的话，我想应该还是有所帮助的。

# 面向对象编程的思想

对于像我一样的嵌入式程序员来说，学会面向对象的编程思想是非常有必要的，为啥呢？因为我是做嵌入式的，举个我工作中的例子呗。例如要开发一款OLED液晶屏驱动，好，你写好了，给客户发过去了，客户也使用你的驱动，用的很爽，也将他的工程写好了。后来发现他选择的OLED似乎不满足要求，客户要求重新写驱动，但是不能改接口，因为代码量太大了，难以维护。
这时候问题来了，重写？但是函数命名问题和接口定义怎么办？显然这样代码的可扩展性和复用性都特别的低。那为什么不一开始定义好接口，写通用的接口呢？下面我就说说我在工作中的做法吧。这里就以oled为例子讲解咯。

## 1.定义通用服务函数句柄

首先定义通用的服务句柄，这里用句柄的原因主要是给设备做分类，一个句柄就表示一个（一类）设备。为啥要这样呢？继续往后看。通用句柄定义如下：

``` c
/** \brief oled服务 */
typedef struct oled_serv{
	const struct oled_funcs *funcs; /**< \brief 功能函数    */
	void 						*p_arg;/**< \brief 函数第一个参数 */ 
} oled_serv_t;


typedef oled_serv_t *oled_handle;  /**< oled通用服务句柄 */
```

这里我就简单的列出几个功能函数，讲解方便点，如果需要添加，也就是依葫芦画瓢而已。结构体定义如下：

``` c
/**
 * \brief 功能函数结构体 
 */ 
struct oled_funcs {
	/** \brief 配置字体信息 */
	void (*oled_font_size_config)(void *p_drv, int request);
	
	/** \brief 显示字符串   */ 
	void (*oled_str_show)(void *p_drv, const char *p_data);
	
	/** \brief 显示图片 */ 
	void (*oled_graph_show)(void *p_drv, const char *p_data, size_t size);
}; 
```
这几个函数就是具体的OLED驱动驱动给上层接口提供的，这些接口都是抽象的行为函数，类似一个虚函数表，那具体的实现就应该在具体的驱动实现。下面是行为函数，定义如下：

``` c
/** broef 字符大小设置 */
inline
static void oled_font_size_cfg (oled_handle handle, int request)
{
	handle->funcs->oled_font_size_config(handle->p_arg, request);
}

/** \brief 显示字符 */
inline
static void oled_str_show(oled_handle handle, const char *p_str)
{
	 handle->funcs->oled_str_show(handle->p_arg, p_str);
} 

/** \brief 显示图片 */
inline
static void oled_graph_show(
	oled_handle handle, const char *p_buf, size_t size)
{
	 handle->funcs->oled_graph_show(
	 				handle->p_arg, p_buf, size);
}
```

以上就是一个通用接口的设计了，但是我这个通用接口只有一堆的虚函数，没有具体的实现，显然是不可以使用的。下面我们虚拟一个设备来实现来实现。

## 2.添加设备

我们要使用通用接口，那具体的设备肯定要继承他的方法咯。然后就是拓展具体设备自己的属性。示例如下：

``` c
/** \brief 设备信息结构体 */
typedef struct oled1_info {
	const char *name; /* 设备名 */
	// Users can add members... idle
}oled1_info_t; 

/** \brief oled设备 */
typedef struct oled1 {
	oled_serv_t          isa;  /**< \brief 继承oled通用设备 */ 
	const oled1_info_t  *info; /**< \brief 设备信息         */ 
	// Users can add members... idle
}oled1_t;

/** \brief 设备句柄 */
typedef oled1_t *oled1_handle;
```












































































































