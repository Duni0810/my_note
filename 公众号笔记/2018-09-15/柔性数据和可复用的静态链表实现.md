---
title: 柔性数据和可复用的静态链表实现
tags: young
grammar_abbr: true
grammar_table: true
grammar_defList: true
grammar_emoji: true
grammar_footnote: true
grammar_ins: true
grammar_mark: true
grammar_sub: true
grammar_sup: true
grammar_checkbox: true
grammar_mathjax: true
grammar_flow: true
grammar_sequence: true
grammar_plot: true
grammar_code: true
grammar_highlight: true
grammar_html: true
grammar_linkify: true
grammar_typographer: true
grammar_video: true
grammar_audio: true
grammar_attachment: true
grammar_mermaid: true
grammar_classy: true
grammar_cjkEmphasis: true
grammar_cjkRuby: true
grammar_center: true
grammar_align: true
grammar_tableExtra: true
---
==文档制作工具：小书匠（markdown工具）==
==制作人     ：young==
==制作时间：2018-9-15==


----------

这篇文章我们来讲解下什么柔性数组，具体的应用是什么和还有静态链表的实现。

# 1.  柔性数组

## 1.1 柔性数组的定义

我们先来说说什么是柔性数组。

柔性数组
 : 结构中**最后一个元素**允许是未知大小的数组，这个数组就是柔性数组。
 直接给一个实例定义看看是啥玩意儿：
 

``` c
typedef struct soft_array
{
    int len;
    int array[]; // 柔性数组
} soft_array_t;
```

 换句话说，实际上柔性数组是一个不定长的数值，也就是我们常说的不完整类型，如果我们直接定义的话，编译报错，但是我们赋值的话，不会报错。如下:
 
``` C 
 a[];  // 编译报错
 a1[] = "young test!"; //编译成功
```
上面说到柔性数组的一个不定长的数值，那他在程序中的内存是什么分布的呢？下面我们写一段代码测试一下柔性数组在内存中的表示：

``` c
#include <stdio.h>

typedef struct soft_array {
    int len;
    int array[]; // 柔性数组
} soft_array_t; 

int main()
{
    soft_array_t test;
    printf("size of struct:%ld \r\n", sizeof(test));
    return 0;
}
```
![柔性数值测试输出结果](./images/柔性数组.JPG)

## 1.2 柔性数组的使用

我们可以看到输出的结果为4字节，只有一个int的大小，并没有柔性数组的空间大小。我们知道指是会占用一个指针大小的空间的，但是柔性数值只会占用一个占位符号，不占用任何的空间。
这里我们可以再写一个实例，看下既然是不定长的数组，那我们应该怎么使用他呢？看下面的代码：

``` c
#include <stdio.h>
#include <malloc.h>
#include <string.h>

typedef struct soft_array {
    int  len;
    char array[];
} soft_array_t;

#define  VAL "young test string."

//创建柔性数组
soft_array_t *creat_soft_array(int num)
{
    soft_array_t *ret = NULL;
    
    if(num > 0) {
        //printf("size num:%ld \r\n", sizeof(soft_array_t) + sizeof(*(ret->array)) * num);
        ret = (soft_array_t *)malloc((sizeof(soft_array_t) + sizeof(*(ret->array))) * num);
        //初始化
        memset(ret->array, 0, sizeof(*(ret->array) * num));
        ret->len = num;
    }
    return ret;
}

int main ()
{
    // 申请20个字节的空间
    soft_array_t *array = creat_soft_array(20);
   
    strcpy(array->array, VAL);
    printf("str:%s \t len:%d\r\n",array->array, array->len);

    free(array);
    return 0;
}
```
![柔性数组的应用-测试结果](./images/柔性数组的应用.JPG)

上面简单的代码测试过程我们很容易得出柔性数组的基本作用，当我们结构体想分配一个不固定的内存空间的时候，柔性数组会自动指向那段内存，使用柔性数组的优势是他本身不占用任何空间。
当然柔性数组和指针很像，但是与指针还有有一些本质上的不同，比如指针可以在结构体中的任何一个位置，但是如果想要使用**柔性数组必须放在结构体中的最后的位置**；我们指针使用比较灵活，可以指针指向的位置可以是任意的不连续的，但是我们使用柔性数值内部必然是连续的；在结构体中指针是会占用一定大小的空间，但是**柔性数组不会占用空间，只会占用一个符号而已，可以单做一个地址符号。**


# 2.  静态链表

## 2.1 静态链表的定义

为什么要理解柔性数值呢？主要是为了讲解下面的静态链表，那什么是静态链表呢？既然使用柔性数组表示的链表，我们可以简单的理解他的定义：**就是用数值来表示的链表，就是静态链表。**
我们之前说过单链表，这个就是一个动态的链表，比如在linux内核中应用的比较广泛，那静态链表的在哪些场合中使用呢？例如我们使用的TCP/IP协议，还有需要动态生成ID的场合等。

## 2.2 静态链表的原理

那下面我们来画张图讲解下这东西的具体实现是什么样子的。

![静态链表原理](./images/静态链表原理.JPG)

如上图我们知道静态链表的最少有两个数据段，一个是data，另一个就是next，这个和我们的单链表类似，**只是我们这里的next表示的是下一个元素在数组中存放的数值下标**。例如我们的链表从第0个元素开始，他的next值为2，表示他的下一个元素存在数组下标为2的地址中；下标为2的元素的next为3，表示他的下一个元素的地址存储在表为数组下标为3的地址中；数组下标为3的next值存储为6，表示他的下一个元素存储在数组下标为6的位置，以此类推。

其实本质山静态链表的实现和我们单链表的实现是差不多的。那么我们现在来看看静态链表的一些函数定义。

``` c
// 节点结构体的定义
typedef struct static_list_node {
	unsigned int data;
	int next;
} static_list_node_t;

// 静态链表结构体定义
typedef struct static_list {
	int capcity; // 静态链表的大小
	static_list_node_t header; // 表头
	static_list_node_t node; // 容纳静态链表元素数组
} static_list_t;
```




























