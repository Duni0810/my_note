---
title: 设计模式之封装，继承及多态
tags: young
grammar_abbr: true
grammar_table: true
grammar_defList: true
grammar_emoji: true
grammar_footnote: true
grammar_ins: true
grammar_mark: true
grammar_sub: true
grammar_sup: true
grammar_checkbox: true
grammar_mathjax: true
grammar_flow: true
grammar_sequence: true
grammar_plot: true
grammar_code: true
grammar_highlight: true
grammar_html: true
grammar_linkify: true
grammar_typographer: true
grammar_video: true
grammar_audio: true
grammar_attachment: true
grammar_mermaid: true
grammar_classy: true
grammar_cjkEmphasis: true
grammar_cjkRuby: true
grammar_center: true
grammar_align: true
grammar_tableExtra: true
---
==文档制作工具：小书匠（markdown工具）==
==制作人     ：young==
==制作时间：2019-3-22==


----------

好吧，从这篇文章开始我们重新开始聊聊设计模式吧。毕竟一开始的代码量大了也是有点吃不消，循序渐进才是硬道理。
那么这篇文章呢，我就介绍下用C语言如何实现像C++这种面向对象语言。我们知道面向过程就是分析解决问题的步骤，然后用函数把这些步骤一步一步的进行实现，在使用的时候进行一一调用就行了，注重的是对于过程的分析。面向对象则是把构成问题的事进行分成各个对象，建立对象的目的也不仅仅是完成这一个个步骤，而是描述各个问题在解决的过程中所发生的行为。

我们也知道所有的面向对象语言都有三大特性：封装，继承以及多态。那封装是什么？继承是什么？多态又是什么呢？下面我结合自己的想法和百度上的资料总结下我自己的理解。

## 封装

关于封装嘛，我的理解就是将一系列的全局变量和设备的特性包含在一个结构体中而已，当然这个是个人理解狭义的封装。C++中的封装应该有一些私有变量(属性)，不能直接改变，只能通过接口修改他。这个实现我在之前的写数据结构中有用到过，这里用一个链表的代码解释下封装的概念：

main.c 文件中实现链表的创建：

``` c
struct Value {
	LinkListNode_t header;
	int            data; 
}; 

int main(int argc, char *argv[]) {
	int i = 0;
	LinkList *list = LinkList_Create(); /* 创建头节点 */ 
	struct Value v1;
    struct Value v2;
	
	// todo
	
	return 0;
	}
```

因为链表的创建是需要申请空间的但是没有显现出来，只是返回一个LinkList * 类型的数据。实际上 list类型是void * 类型，用void * 主要为了做数据封装，他的类型在底层函数中做解析，现在看下底层实现。

list.c 文件

``` c
/** \brief 链表信息 */
typedef struct _tag_ListNode {
	LinkListNode_t hander; /* 链表的头指针 */ 
	int length;            /* 链表长度     */ 
} TListNode_t;

/**
 * \brief 创建一个节点 
 *
 * \ret  节点的地址 
 */ 
LinkList* LinkList_Create (void)
{
    TListNode_t *ret = (TListNode_t *)malloc(sizeof(TListNode_t));
	
	if (ret != NULL) { /* 申请空间成功赋初值 */
		ret->hander.next = NULL;
		ret->length = 0; 
	} 
	return ret;
}

// …… todo

/**
 * \brief 获取链表长度 
 *
 * \param list[in]  链表的头节点 
 *
 * \ret 链表的长度 
 */ 
int LinkList_Length_Get (LinkList* list)
{
	TListNode_t *slist = (TListNode_t *)list;
	
	int ret = -1;
	
	if (NULL != slist) {
		ret = slist->length;
	}
	
	return ret;
}
```

欸，注意到了没，我在底层中使用了一个结构体管理链表的实现，并且我申请了空间，这个结构体主要保存了链表的头指针和链表的长度，但是用户是看不到我这个结构体，只能使用，具体实现是就是我底层自己解析的了。

