---
title: 设计模式原则
tags: young
grammar_abbr: true
grammar_table: true
grammar_defList: true
grammar_emoji: true
grammar_footnote: true
grammar_ins: true
grammar_mark: true
grammar_sub: true
grammar_sup: true
grammar_checkbox: true
grammar_mathjax: true
grammar_flow: true
grammar_sequence: true
grammar_plot: true
grammar_code: true
grammar_highlight: true
grammar_html: true
grammar_linkify: true
grammar_typographer: true
grammar_video: true
grammar_audio: true
grammar_attachment: true
grammar_mermaid: true
grammar_classy: true
grammar_cjkEmphasis: true
grammar_cjkRuby: true
grammar_center: true
grammar_align: true
grammar_tableExtra: true
---
==文档制作工具：小书匠（markdown工具）==
==制作人     ：young==
==制作时间：2019-4-3==


----------

这周我们讲设计模式的六大设计原则，分别：

* 单一职责原则
* 里氏替换原则
* 依赖倒置原则
* 接口隔离原则
* 迪米特法则
* 开闭原则

下面我一一来简单的讲诉下他们所代表的东西，这篇文章可能有点枯燥，但是这个是设计模式的精髓也是基础的东西。

## 单一职责原则

在设计模式中，单一性原则比较简单，咱们从字面意义上就知道了，就是职责单一化。例如我们在写一个类中的行为(上篇文章也说了，类在C中就是结构体，行为一般表现为函数)，那么这个行为在设计的时候尽量单一化，不要混合使用，在函数中当然是接口越简单越好。
使用单一原则也是有好处的，例如项目中使用一款芯片，现在升级了芯片，实现不同了，但是对于维护代码而言，我至于要换一个实现就是，不需要一股脑全换。对于代码的维护是有很大好处。
==其实单一性职责原则是最难划分的就是职责。== 因为一个职责一个接口，但是问题是“职责”是没有量化的标准，一个类到底要负责哪些职责？这些职责怎么细化？细化后是否还需要一个接口（类）？所以单一职责原则是不可度量的，使用因项目而异，因环境而异。
单一性原则是不可缺少的一部分，因为可以提高代码的可维护性，但是生搬硬套会引起类的剧增，本来一个类就可以实现的硬生生的分成两个类，认为的增加了复杂性。所以**原则是死的，人是活的，这句话很有道理。**

## 里氏替换原则

那什么是里氏替换原则呢？先来一个定义：所有引起基类的地方必须能透明地使用其子类的对象。
好，这里提到了基类和子类，之前提到过继承，这里就不提及了，通俗点说就是：==只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何的错误或者异常，使用者可以不知道父类是谁，子类是谁。但是反过来就不可以了，有子类的地方，父类未必能适应。==

这个怎么说呢？说白了就是继承关系呗，在C中的继承关系上篇文章已经说过了，就是结构体的嵌套，里氏替换只是给这个继承添加了一个约束条件而已。其他的与集成并没有什么很大区别。
我们采用里氏替换原则的目的主要是增强程序的健壮性，在我们做版本升级时候可以保持很好的兼容性，即使我们增加了子类，原来的子类也是可以运行的。
还有一点，在代码中，我们尽量避免用子类当作父类来使用，因为这样会导致代码可读性大大降低，例如下面这个例子：

``` c
typedef struct people {
	int     age;			// 年龄
	char name[20]；			 // 名字 
} people_t;

typedef struct student {
    people_t isa;
    char class[10];			// 班级
} student_t;

int main()
{
    student_t  stu;
	// todo
	((people_t *)&stu)->age = 20;
	// todo
	
	return 0;
}
```
## 依赖倒置原则

依赖倒置原则这个名字看着有点别扭，“依赖”还“倒置”，这个是什么意思？大体上是这么一个意思：

* 高层模块不应该依赖底层模块，两者都应该依赖其抽象；
* 抽象不应该依赖于细节；
* 细节应该以来抽象；

在这里高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑（小函数或者寄存器）组成，不可分割的低层逻辑就是模块，原子模块的堆叠就是高层模块。
那什么是抽象？什么又是细节呢？这个在之前的文章有提到过，抽象可以是一堆的虚函数表，其实就是一堆的函数指针；细节就是具体的实现类，实现接口而产生的类就是细节，他们可以被实例化。这个之前很多的代码都是使用这个方法实现的。他的表现就是：

 * 模块间的依赖通过抽象发生，实现类之间不发生直接的以来关系，其依赖关系通过接口或者抽象类产生；
 * 接口或者抽象类不依赖于实现类；
 * 实现类依赖接口或者抽象；
说白了就是我之前写的面向接口编程。其实依赖倒置原则在小型项目是不好体现出他的优点的，但是在稍微大点的项目中的优势是十分的突出，主要是做接口的复用，同样的代码，用户可以忽略细节的实现。
当然，我们使用依赖倒置原则尽量结合里氏替换原则，提高代码的健壮性。

## 接口隔离原则

看过我之前的文章的旁友们，对接口的隔离应该不陌生，之前写的文章大多数都做了接口隔离，接口可以分两类：实例接口，类接口。这个在前面也提到了，不做过多的赘述。
我的总结是这样的：**建立单一接口，不要建立臃肿的接口**。通俗点说就是：接口尽量细化，同时接口中的方法尽量少。看到这里，是不是想起了单一性原则？哈，这个还真的有点不同，==因为他们的审视角度不同，单一原则是类和接口职责单一，注意的是这个是职责，重点是职责，是业务逻辑上的单一化。而接口隔离是要求接口的方法尽量少。==

例如：一个接口中可能包含10个方法，这10个方法都放在一个接口中，并提供多个模块访问，各个模块按照规定的权限访问。这个例子中按照单一职责原则是允许的，按照接口隔离原则是不允许的。因为他要求“尽量使用多个专门的接口”。
那什么是专门的接口？就是指提供给每一个模块的都应该是单一的接口，有几个模块就应该有几个接口。

``` c
// handle 句柄
// type     类型
// p_arg  参数
err_t control(void *handle, uint8_t type, void *p_arg)
{
	uint8_t error = 0;
	switch(type)
	{
	case 0:
		{
		// todo function
			break;
		}
		
	case 1:
		{
		// todo function
			break;
		}
		// todo add some case
		
		default :
		{
			break;
		}
		
	}

	return error;
}
```

## 迪米特法则

这个原则可能陌生了，但是很有意思。定义：一个被定义的对象应该对其他对象有最少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道得最少。
这个就和你找女朋友一样，你找到一个女朋友，就应该对其他姑娘保持距离，(最少的了解)。当然两个人在一起，装傻也是必要的，有些东西并不是知道的越多越好，反而是越少越好，谁认真谁就输了。

关于迪米特法则对类的低耦合提出了明确的要求，大概有如下3层含义：

1. 只与直接的朋友通信；
什么是直接的朋友？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就是朋友关系。

2. 朋友间也是有距离的；
人和人之间应该是距离产生美，太远容易形同陌路，太近就互相刺伤。之前看到过一幅漫画，就是对朋友关系描述最贴切的例子：两只刺猬取暖，太远取不到暖，太近刺伤对方，必须保持一个既能取暖又不刺伤对方的距离。迪米特法则就是对这个距离进行描述，即使是朋友也不能无话不说，无所不知。

3. 是自己的就是自己的；
在实际中，经常会出现这样一个方法：放在本类中也可以，放在其他类中也没有错？那怎么去衡量呢？这个时候就要遵循这么一个原则：如果一个方法放在本类中，既不增加类间关系，对本类中不产生负面影响，那就放置在本类中。

**==总而言之，迪米特法则的核心观念就是类间的解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。==**


## 开闭原则

在哲学上，矛盾法是对立与统一的法则。那么开闭原则其实也是如此。他的定义如下：一个软件实体，如类，模块和函数应该对扩展开放，对修改关闭。
是不是看这个定义有点怪，对扩展开放？开放什么？对扩展关闭？关闭什么？

其实是这样的，一个软件实体应该通过扩展来实现变化，而不是通过修改代码来实现变化。这个好理解，我们在大型项目中，对于修改代码这个事情是很头疼的事情，如果是新手，可能不知道你修改的代码耦合性，不知道你修改后的代码对其他代码有什么影响，所以一般情况下我们只是通过扩展软件实体来实现变化，而不是通过修改代码的形式来修改变化。

为什么要用开闭原则？每个事物的诞生都有它存在的必要性，存在必然合理，那么开闭原则的存在也是合理的。其实这里说的开闭原则是最基础的一个原则，前面提到的5个原则都是开闭原则具体形态，也就是说前五个原则就是指导设计的工具和方法，而开闭原则才是他们的精神领袖。
换一个例子：开闭原则是一个非常虚的原则，类似于”好好学习，天天向上“这样的口号，告诉我们要好好学习，但是没告诉我们学什么，开闭原则就是这个口号。



好了，今天就写到这里了，这篇文章文字比较多，但是看完还是有点收获的吧，我相信。

![CYoung](./images/二维码.jpg)




