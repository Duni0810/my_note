---
title: 设计模式原则
tags: young
grammar_abbr: true
grammar_table: true
grammar_defList: true
grammar_emoji: true
grammar_footnote: true
grammar_ins: true
grammar_mark: true
grammar_sub: true
grammar_sup: true
grammar_checkbox: true
grammar_mathjax: true
grammar_flow: true
grammar_sequence: true
grammar_plot: true
grammar_code: true
grammar_highlight: true
grammar_html: true
grammar_linkify: true
grammar_typographer: true
grammar_video: true
grammar_audio: true
grammar_attachment: true
grammar_mermaid: true
grammar_classy: true
grammar_cjkEmphasis: true
grammar_cjkRuby: true
grammar_center: true
grammar_align: true
grammar_tableExtra: true
---
==文档制作工具：小书匠（markdown工具）==
==制作人     ：young==
==制作时间：2019-4-3==


----------

这周我们讲设计模式的六大设计原则，分别：

* 单一职责原则
* 里氏替换原则
* 依赖倒置原则
* 接口隔离原则
* 迪米特法则
* 开闭原则

下面我一一来简单的讲诉下他们所代表的东西，这篇文章可能有点枯燥，但是这个是设计模式的精髓也是基础的东西。

## 单一职责原则

在设计模式中，单一性原则比较简单，咱们从字面意义上就知道了，就是职责单一化。例如我们在写一个类中的行为(上篇文章也说了，类在C中就是结构体，行为一般表现为函数)，那么这个行为在设计的时候尽量单一化，不要混合使用，在函数中当然是接口越简单越好。
使用单一原则也是有好处的，例如项目中使用一款芯片，现在升级了芯片，实现不同了，但是对于维护代码而言，我至于要换一个实现就是，不需要一股脑全换。对于代码的维护是有很大好处。
其实单一性职责原则是最难划分的就是职责。因为一个职责一个接口，但是问题是“职责”是没有量化的标准，一个类到底要负责哪些职责？这些职责怎么细化？细化后是否还需要一个接口（类）？所以单一职责原则是不可度量的，使用因项目而异，因环境而异。
单一性原则是不可缺少的一部分，因为可以提高代码的可维护性，但是生搬硬套会引起类的剧增，本来一个类就可以实现的硬生生的分成两个类，认为的增加了复杂性。所以原则是死的，人是活的，这句话很有道理。

## 里氏替换原则

那什么是里氏替换原则呢？先来一个定义：所有引起基类的地方必须能透明地使用其子类的对象。
好，这里提到了基类和子类，之前提到过继承，这里就不提及了，通俗点说就是：只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何的错误或者异常，使用者可以不知道父类是谁，子类是谁。但是反过来就不可以了，有子类的地方，父类未必能适应。

这个怎么说呢？说白了就是继承关系呗，在C中的继承关系上篇文章已经说过了，就是结构体的嵌套，里氏替换只是给这个继承添加了一个约束条件而已。其他的与集成并没有什么很大区别。
我们采用里氏替换原则的目的主要是增强程序的健壮性，在我们做版本升级时候可以保持很好的兼容性，即使我们增加了子类，原来的子类也是可以运行的。
还有一点，在代码中，我们尽量避免用子类当作父类来使用，因为这样会导致代码可读性大大降低，例如下面这个例子：

``` c
typedef struct people {
	int     age;			// 年龄
	char name[20]；			 // 名字 
} people_t;

typedef struct student {
    people_t isa;
    char class[10];			// 班级
} student_t;

int main()
{
    student_t  stu;
	// todo
	((people_t *)&stu)->age = 20;
	// todo
	
	return 0;
}
```
## 依赖倒置原则

依赖倒置原则这个名字看着有点别扭，“依赖”还“倒置”，这个是什么意思？大体上是这么一个意思：

* 高层模块不应该依赖底层模块，两者都应该依赖其抽象；
* 抽象不应该依赖于细节；
* 细节应该以来抽象；

在这里高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑（小函数或者寄存器）组成，不可分割的低层逻辑就是模块，原子模块的堆叠就是高层模块。
那什么是抽象？什么又是细节呢？这个在之前的文章有提到过，抽象可以是一堆的虚函数表，其实就是一堆的函数指针；细节就是具体的实现类，实现接口而产生的类就是细节，他们可以被实例化。这个之前很多的代码都是使用这个方法实现的。他的表现就是：

 * 模块间的依赖通过抽象发生，实现类之间不发生直接的以来关系，其依赖关系通过接口或者抽象类产生；
 * 接口或者抽象类不依赖于实现类；
 * 实现类依赖接口或者抽象；
说白了就是我之前写的面向接口编程。其实依赖倒置原则在小型项目是不好体现出他的优点的，但是在稍微大点的项目中的优势是十分的突出，主要是做接口的复用，同样的代码，用户可以忽略细节的实现。
当然，我们使用依赖倒置原则尽量结合里氏替换原则，提高代码的健壮性。

## 接口隔离原则

看过我之前的文章的旁友们，对接口的隔离应该不陌生，之前写的文章大多数都做了接口隔离，接口可以分两类：实例接口，类接口。这个在前面也提到了，不做过多的赘述。
我的总结是这样的：建立单一接口，不要建立臃肿的接口。通俗点说就是：接口尽量细化，同时接口中的方法尽量少。看到这里，是不是想起了单一性原则？哈，这个还真的有点不同，因为他们的审视角度不同，单一原则是类和接口职责单一，注意的是这个是职责，重点是职责，是业务逻辑上的单一化。而接口隔离是要求接口的方法尽量少。

例如：一个接口中可能包含10个方法，这10个方法都放在一个接口中，并提供多个模块访问，各个模块按照规定的权限访问。这个例子中按照单一职责原则是允许的，按照接口隔离原则是不允许的。因为他要求“尽量使用多个专门的接口”。
那什么是专门的接口？就是指提供给每一个模块的都应该是单一的接口，有几个模块就应该有几个接口。

``` c
err_t control(void *handle, uint8_t type, void *p_arg)
{
	uint8_t error = 0;
	//todo
	return error;
}
```

## 迪米特法则

## 开闭原则

