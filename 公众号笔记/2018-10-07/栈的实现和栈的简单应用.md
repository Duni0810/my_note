---
title: 栈的实现和栈的应用实例
tags: young
grammar_abbr: true
grammar_table: true
grammar_defList: true
grammar_emoji: true
grammar_footnote: true
grammar_ins: true
grammar_mark: true
grammar_sub: true
grammar_sup: true
grammar_checkbox: true
grammar_mathjax: true
grammar_flow: true
grammar_sequence: true
grammar_plot: true
grammar_code: true
grammar_highlight: true
grammar_html: true
grammar_linkify: true
grammar_typographer: true
grammar_video: true
grammar_audio: true
grammar_attachment: true
grammar_mermaid: true
grammar_classy: true
grammar_cjkEmphasis: true
grammar_cjkRuby: true
grammar_center: true
grammar_align: true
grammar_tableExtra: true
---
==文档制作工具：小书匠（markdown工具）==
==制作人     ：young==
==制作时间：2018-10-7==


----------

# **1. 栈**

这篇文章我们来讲下数据结构中的栈的实现和应用。文章中的栈实现我是通过之前的单链表实现。其实数据结构中的栈是一种特殊的数据结构，他的特点就是先进后出（相当于栈只是在线性表的其中一端进行操作）。

![栈的原理](./images/栈介绍.jpg)

栈的核心就4个字先进后出（first in last out）。

好吧，说了一些文字够了，下面说说他的实现的细节介绍。

## **1.1  栈的基本操作与实现**

栈的一些操作和链表的差不多，只是他只是在一端操作而已，看下面的基本操作吧。
* 创建栈
* 销毁栈
* 清空栈
* 进栈
* 出栈
* 获取栈顶元素
* 获取栈的大小

其实我们不用重新实现一个栈，我们只需要单链表的基础上重新封装一层就可以用了。看看我们都要注意哪些操作和怎么实现的。

首先，我们这里实现的是一个链式栈，所以要一个结构体保存一些信息咯。如下：

``` c
typedef struct _tag_LinkStackNode {
	LinkListNode_t header;   // 首元素
	void  *item;			   // 栈元素地址保存 
} LinkStack_Node_t;
```
关于栈的其他操作都是套用之前学过的链表操作实现，具体代码如下：

``` c
// 1.创建栈 
LinkStack *LinkStack_Create()
{
	return LinkList_Create();
} 

// 2. 摧毁栈 
int LinkStack_Destroy(LinkStack *stack)
{
	int ret = (stack != NULL);
	
	if (ret) {
		LinkStack_Clear(stack);
		LinkList_Destroy(stack);
		return OK;
	} 
	// 先清空栈 
	return ERROR;
}

// 3.清空栈
int LinkStack_Clear(LinkStack *stack)
{
	int ret = (stack != NULL) ;
	
	if (ret) {
			// 必须先弹栈 否则会内存溢出 
		while (LinkStack_Size(stack) > 0) {
			LinkStack_Pop(stack);
		}
		return OK;
	} 

	return ERROR;
}

// 4.压栈
// 得先申请一个空间，然后压栈 
int LinkStack_Push(LinkStack* stack, void *item)
{
	LinkStack_Node_t *node = (LinkStack_Node_t *)malloc(sizeof(LinkStack_Node_t));
	int ret = (node != NULL) && (item != NULL) && (stack != NULL);
	
	if (ret) {
		node->item = item; // 保存的item 
		//压栈 
		ret = LinkList_Insert(stack, (LinkListNode_t *)node, 0);
	}
	
	// 压栈失败 释放空间 
	if (!ret) {
		free (node);
	} 
	return ret; 
}

// 5.弹栈
// 删除第一个元素 
LinkStack *LinkStack_Pop(LinkStack *stack)
{
	// 删除第一个元素 
	LinkStack_Node_t *node = (LinkStack_Node_t *)LinkList_Delete(stack, 0);
	void *ret  = NULL;
	
	// 第一个元素删除成功 
	if (node != NULL) {
		ret = node->item;
		
		// 释放空间 
		free(node);
	} 
	return ret;
}

// 6.栈顶 
LinkStack *LinkStack_Top(LinkStack *stack)
{
	LinkStack_Node_t *node = (LinkStack_Node_t *)LinkList_Get(stack, 0);
	void *ret  = NULL;
	
	if (node != NULL) {
		ret = node->item;
	} 
	return ret;
}

// 7.栈大小
int LinkStack_Size(LinkStack *stack)
{
	return LinkList_Length_Get(stack); 
} 
```
代码中可以看出我们实际写的代码不多，基本上套用写过的代码。这里我们讲讲他们的细节和为什么要这样做。

### 1.1.1 压栈

很明显，我们要压栈的，必须申请一个空间，然后将元素插入到链表的头部即可，但是如果我们申请空间失败，一定要记得释放空间，防止内存泄露。

#### 1.1.2 弹栈

弹栈也是一样，我们弹出的位置就是链表的第一个位置，其实是就是删除链表的第一个位置，然后释放空间，避免内存泄露。

#### 1.1.3 清空栈
这里可能有点不同，我们在链表中的清空是直接将头信息置为0（头指针指向NULL）；但是在栈中这样做容易造成内存泄露。所以我们要一个一个的弹出栈，直到为栈空间为0为止。

#### 1.1.4 释放栈
在摧毁栈之前，必须将栈中的数据全部弹出，然后才能释放栈内存。









































